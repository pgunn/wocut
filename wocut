#!/usr/bin/perl -w

use strict;
use warnings FATAL => qw(all);
use YAML::XS; # In Debian, you want the libyaml-libyaml-perl package for this.

my $nevermark = 99999; # Mark that we use to discard packets
my $servicedir = qq{/etc/wocut};

my $debuglvl = 1;
my $doit = 1;
main();

###########################
# wocut - Manage random redirection of incoming connections to one port
#	to a bunch of ports. Manage several such profiles at the same time,
#	treating them like SysVInit services and keeping track of ones to
#	restore on boot, let users start/stop them individually.
#
# Written by Pat Gunn, November 2013. Public Domain.
# Thanks to the #iptables channel for informing me of the feature
# this depends on.

sub main
{
my %cfg = handle_args(@ARGV);
if(	$cfg{cmd} eq 'start')		{dispatch_start(	%cfg);}
elsif(	$cfg{cmd} eq 'stop')		{dispatch_stop(		%cfg);}
elsif(	$cfg{cmd} eq 'define')		{dispatch_define(	%cfg);}
elsif(	$cfg{cmd} eq 'undefine')	{dispatch_undefine(	%cfg);}
elsif(	$cfg{cmd} eq 'list')		{dispatch_list(		%cfg);}
elsif(	$cfg{cmd} eq 'stats')		{dispatch_stats(	%cfg);}
}

sub handle_args
{
my @args = @_;
my %cfg;

if(! @args) {usage();}

$cfg{cmd} = shift(@args);
if($cfg{cmd} eq 'list')
	{ # Takes no additional args
	if(@args) {usage();}
	}
elsif(	($cfg{cmd} eq 'start')
||	($cfg{cmd} eq 'stop' )
||	($cfg{cmd} eq 'undefine')
||	($cfg{cmd} eq 'stats') )
	{ # Take one arg, the name of the service
	if(@args != 1) {usage();}
	$cfg{service} = shift(@args);
	}
elsif($cfg{cmd} eq 'define')
	{ # Take service name and a definition (many components, defer parsing)
	if(@args < 2) {usage();}
	$cfg{service} = shift(@args);
	$cfg{definition} = \@args; # Stash the whole thing for more parsing later
	}
else	{usage();}
return %cfg;
}

sub usage
{
die "Usage: wocut COMMAND\n"
.	"\tCOMMAND is one of:\n"
.	"\t\tlist\n"
.	"\t\tstats SERVICE\n"
.	"\t\tstart SERVICE\n"
.	"\t\tstop SERVICE\n"
.	"\t\tdefine SERVICE DEFINITION\n";
}

################
# Dispatch functions

sub dispatch_list
{
my %cfg = @_;

my %services = read_services();
foreach my $service (sort {$a cmp $b} keys %services)
	{

	}
}

sub dispatch_stats
{ # "service" key says which one
my %cfg = @_;
}

sub dispatch_start
{ # "service" key says which one
my %cfg = @_;
}

sub dispatch_stop
{ # "service" key says which one
my %cfg = @_;
}

sub dispatch_define
{ # "service" key says which one, "definition" key is a listref that defines the service.
my %cfg = @_;
}

sub dispatch_undefine
{ # "service" key defines which one. Implies "stop".
my %cfg = @_;
}

#################
# Handle wocut files

sub read_services
{	# Read all services from the servicedir into a hash, return that. Keys are shortnames
	# The value of that hash is another hash with keys:
	#	inport
	#	ports
	#	description
	#	proto (tcp or udp usually, likely won't work with anything else)
	#	auto
	# TODO: If we want to get fancy, report on potential port conflicts.
opendir(WODIR, $servicedir) || die "Failed to open wocut servicedir [$servicedir]: $!\n";
my @servicefiles = 	grep	{/\.wocut$/}
			readdir(WODIR);
close(WODIR);
my %services;
map	{
	my ($svc, %cfg) = _read_service($_);
	$services{$svc} = \%cfg;
	} @servicefiles;
return %services;
}

sub save_service
{	# Save a service the user has provided via CLI into the servicedir
my ($svcname, %cfg) = @_;

_write_service("$servicedir/$svcname.wocut", %cfg);
}

sub serviceauto_set
{
my ($svc, $truefalse) = @_;
my %data = _read_service("$servicedir/$svc.wocut");
$data{auto} = $truefalse ? 1 : 0;
_write_service("$servicedir/$svc.wocut", %data);
}

sub serviceautos_read
{
my ($svc) = @_;
my %data = _read_service("$servicedir/$svc.wocut");
return $data{auto};
}

sub service_status
{ # Report on if service is defined, and if it is, whether it's enabled.
	# This doesn't guarantee the service is working; it only checks
	# One rule in the chain. If users go in and add/delete/change rules, they're on their own.
	# Returns:
	#	0 - If the service is not defined
	#	1 - If the service is defined but not active
	#	2 - If the service is defined and active

my ($svcname) = @_;

my %allsvc = read_services();
if(defined $allsvc{$svcname})
	{
	if(grep{/wocut-$svcname:/} qx/iptables -t nat -v -n -L PREROUTING/)
		{return 2;}
	else	{return 1;}
	}
return 0; # Service is not defined.
}

sub service_statistics
{ # Returns usage statistics on the named service based on iptables counters.
	# TODO: Offer the option of inserting no-target rules in the raw table to actually count
	#	traffic. When we do that, we can look for those here.
my ($svcname) = @_;

my @lines = grep {/wocut-$svcname:/}
	map {s/^\s+//}
	grep {! /^Chain/}
	qx/iptables -t nat -v -n -x -L PREROUTING/; # The -x flag gives us raw numbers rather than suffices.

# So now @lines will be of format:
# $packets $bytes $RULE
my ($remarkline) = grep {/wocut-$svcname: initialmark/} @lines;
my @redirlines = grep {/wocut-$svcname: redirect/} @lines;

# Looking at the packets listing will give us an estimate for the number of connections routed
# through this mechanism. The bytes metric here is useless, as it only shows bytes from initial packets.

my ($ipackets) = split(/\s+/, $remarkline);
my %sstats;
foreach my $redirline (@redirlines)
	{
	my ($rpackets) = split(/\s+/, $redirline);
	$redirline =~ /redirect to port (\d+)/;
	my $rport = $1;
	$sstats{$rport} = $rpackets;
	}
return (	totalpackets => $ipackets,
		details => \%sstats);
}

sub _read_service
{ # Read a particular servicefile. 
my ($infile) = @_;

($infile =~ /^([^.])\.wocut$/) || die "Internal error: Can't parse servicename for [$infile]\n";
my $servicename = $1;
my $svcdata = LoadFile($infile) || die "Failed to read wofile [$infile]\n";
return ($servicename, %$svcdata);
}

sub _write_service
{ # Save YAML to a service file.
my ($file, %data) = @_;

DumpFile($file, \%data) || die "Failed to write wofile [$file]\n";
}

###############
# Handle iptables rules

sub ipt_is_present
{	# Note that this does *NOT* check correctness by the current config; it just looks for a single correct crumb. If the user's fucked with the rules,
	# that won't be caught. Be careful.
my ($svcname) = @_;
my @rules_mangle	= `iptables -v -n --line-numbers -L PREROUTING -t mangle`;
map	{
	my ($ruleno) = split(/\s+/);
	return 1;
	} grep{/wocut-$svcname:/} @rules_mangle;
return 0;
}

sub ipt_establish
{
my ($svcname, %service) = @_;
my @dports = @{$service{markports}};
_ipt_do("mangle", "PREROUTING", "-p $service{proto} --state NEW --dport $service{inport} -j MARK --set-mark $dports[0]", "wocut-$svcname: initialmark");
if($service{blockdirect})
	{
	map {_ipt_do("mangle", "PREROUTING", "-p $service{proto} --dport $_ -m mark --set-mark $nevermark", "wocut-$svcname: blockdirect");} @dports;
	}

for(my $portiter = 1, my $probiter = @dports; $portiter < @dports; $portiter++,$probiter--)
	{
	my $lastmark = $dports[$portiter - 1];
	my $probslice = 1 - (1/$probiter);
	_ipt_do("mangle", "PREROUTING", "-p $service{proto} -m mark --mark $lastmark -m statistic --mode random --probability $probslice --set-mark $dports[$portiter]", "wocut-$svcname: remark for port $dports[$portiter]");
	}
foreach my $dport (@dports)
	{
	_ipt_do("nat", "PREROUTING", "-p $service{proto} -m mark --mark $dport -j REDIRECT --to-port $dport", "wocut-$svcname: redirect to port $dport");
	}
}

sub ipt_remove
{ # Cleanly remove a wocut ruleset from iptables
my ($svcname) = @_;

my @rules_mangle	= `iptables -v -n --line-numbers -L PREROUTING -t mangle`;
my @rules_nat		= `iptables -v -n --line-numbers -L PREROUTING -t nat`;
map	{
	my ($ruleno) = split(/\s+/);
	system("iptables -t mangle -D $ruleno");
	} grep{/wocut-$svcname:/} @rules_mangle;
map	{
	my ($ruleno) = split(/\s+/);
	system("iptables -t nat -D $ruleno");
	} grep{/wocut-$svcname:/} @rules_nat;
}

sub _ipt_do
{
my ($table, $chain, $contents, $comment) = @_;
docmd("iptables -t $table -A $chain $contents -m comment --comment \"$comment\"");
}

sub do_nevermark
{ # This establishes rules for packet dropping based on marks in the three chains that are the last to see a packet
foreach my $fchain (qw/INPUT OUTPUT FORWARD/)
	{
	if(! ipt_rule_present("wocut: nevermark", "filter", $fchain))
		{
		_ipt_do("filter", $fchain, "-m mark --mark --nevermark $nevermark -j DROP", "wocut: nevermark");
		}
	}
}

sub ipt_rule_present
{ # Is a rule with the given ruleid (comment) present in the named table/chain?
my ($ruleid, $table, $chain) = @_;

my @rules = `iptables -v -n -L $chain -t $table`;
return scalar grep(/$ruleid/,@rules);
}

#################
# My normal utilities


sub docmd($)
{
my ($cmdline) = @_;
dprint(2, "IPTABLES: [$cmdline]");
if($doit)
	{
	qx/$cmdline/;
	if($? != 0)
		{die "************Command failed!**********\n";}
	}
}

sub dprint($$)
{
my ($loglvl, $msg) = @_;
if($debuglvl >= $loglvl)
	{print "$msg\n";}
}

###################
# It'd be nice to have a set of utility functions that would just parse iptables output, to reduce code duplication.
# Pity the output is so unstructured.
# If we really want to do this right, we need to either:
#	1) always pass the same arguments to iptables to get this information
#		and not cut bits out before handing them to these functions, or
# 	2) Develop and stick to a terminology for the structures we expect are in the string
#
#	To be clear, we're talking about things like -v, -n, and --line-numbers

# sub ipt_hash
# ...

