#!/usr/bin/perl -w

use strict;
use warnings FATAL => qw(all);
use YAML::XS; # In Debian, you want the libyaml-libyaml-perl package for this.

my $nevermark = 99999; # Mark that we use to discard packets
my $servicedir = qq{/etc/wocut};

my $debuglvl = 1;
my $doit = 1;
main();

###########################
# wocut - Manage random redirection of incoming connections to one port
#	to a bunch of ports. Manage several such profiles at the same time,
#	treating them like SysVInit services and keeping track of ones to
#	restore on boot, let users start/stop them individually.
#
# Written by Pat Gunn, November 2013. Public Domain.
# Thanks to the #iptables channel for informing me of the feature
# this depends on.

##############
# Current stumpers:
#	How do we want to manage mark allocation?
#		A perfect system would scan every mangle CT looking for what marks are used,
#		and be able to sanely make use of a highly fragmented mark system, using consecutive
#		marks when possible and scattered marks when not. That's a lot of work.
#
#		A less perfect system would scan those, but would either give up if it couldn't find a
#		nice range to use or would just possibly wrongly assume that any given free mark starts
#		a block of free marks.
#
#		Or we could ask the user to specify this, which might be good anyway if they're going to
#		build more rules around our rules.
#
#		A platinum version of the last solution would ask the user to specify this, and then verify
#		that their choices are safe (this may be particularly difficult if there are other rules that
#		build on the rules this tool puts in). 
#
#		Or... we could just use the convention that mark=destport. Nice and simple, and we can just
#		ask users to heed that. Hmm. I like this.

sub main
{
my %cfg = handle_args(@ARGV);
if(	$cfg{cmd} eq 'start')		{dispatch_start(	%cfg);}
elsif(	$cfg{cmd} eq 'stop')		{dispatch_stop(		%cfg);}
elsif(	$cfg{cmd} eq 'define')		{dispatch_define(	%cfg);}
elsif(	$cfg{cmd} eq 'list')		{dispatch_list(		%cfg);}
elsif(	$cfg{cmd} eq 'stats')		{dispatch_stats(	%cfg);}
}

sub handle_args
{
my @args = @_;
my %cfg;

if(! @args) {usage();}

$cfg{cmd} = shift(@args);
if($cfg{cmd} eq 'list')
	{ # Takes no additional args
	if(@args) {usage();}
	}
elsif(	($cfg{cmd} eq 'start')
||	($cfg{cmd} eq 'stop' )
||	($cfg{cmd} eq 'stats') )
	{ # Take one arg, the name of the service
	if(@args != 1) {usage();}
	$cfg{service} = shift(@args);
	}
elsif($cfg{cmd} eq 'define')
	{ # Take service name and a definition (many components, defer parsing)
	if(@args < 2) {usage();}
	$cfg{service} = shift(@args);
	$cfg{definition} = \@args; # Stash the whole thing for more parsing later
	}
else	{usage();}
return %cfg;
}

sub usage
{
die "Usage: wocut COMMAND\n"
.	"\tCOMMAND is one of:\n"
.	"\t\tlist\n"
.	"\t\tstats SERVICE\n"
.	"\t\tstart SERVICE\n"
.	"\t\tstop SERVICE\n"
.	"\t\tdefine SERVICE DEFINITION\n";
}

################
# Dispatch functions

sub dispatch_list
{
my %cfg = @_;

my %services = read_services();
foreach my $service (sort {$a cmp $b} keys %services)
	{

	}
}

sub dispatch_stats
{ # "service" key says which one
my %cfg = @_;
}

sub dispatch_start
{ # "service" key says which one
my %cfg = @_;
}

sub dispatch_stop
{ # "service" key says which one
my %cfg = @_;
}

sub dispatch_define
{ # "service" key says which one, "definition" key is a listref that defines the service.
my %cfg = @_;
}

#################
# Handle wocut files

sub read_services
{	# Read all services from the servicedir into a hash, return that. Keys are shortnames
	# The value of that hash is another hash with keys:
	#	inport
	#	ports
	#	description
	#	proto (tcp or udp usually, likely won't work with anything else)

}

sub save_service
{ # Save a service the user has provided via CLI into the servicedir

}

sub _read_service
{ # Read a particular servicefile. 
my ($infile) = @_;

($infile =~ /^([^.])\.wocut$/) || die "Internal error: Can't parse servicename for [$infile]\n";
my $servicename = $1;
open(my $wofile, $infile) || die "Failed to read wofile [$infile]\n";
local $/; # Slurp mode
my $yamlfile = readline($wofile);
close($wofile);
my @svcdata = Load($yamlfile);
# TODO What shall we return? Try "cat sample_wocuts/apache.wocut | ysh" to see what we can get
}

sub serviceauto_set
{

}

sub serviceautos_read
{

}

sub service_status
{

}

sub service_statistics
{ # Returns usage statistics on the named service based on iptables counters.

}

###############
# Handle iptables rules

sub ipt_is_present
{	# Note that this does *NOT* check correctness by the current config; it just looks for a single correct crumb. If the user's fucked with the rules,
	# that won't be caught. Be careful.
my ($svcname) = @_;
my @rules_mangle	= `iptables -v -n --line-numbers -L PREROUTING -t mangle`;
map	{
	my ($ruleno) = split(/\s+/);
	return 1;
	} grep{/wocut-$svcname:/} @rules_mangle;
return 0;
}

sub ipt_establish
{
my ($svcname, %service) = @_;
my @dports = @{$service{markports}};
# iptables -t mangle -A PREROUTING -p $service{proto} -m state --state NEW --dport $service{inport} -j MARK --mark-set $dports[0] -m comment --comment "wocut-$svcname: initialmark"
if($service{blockdirect})
	{
	map {_ipt_do("mangle", "PREROUTING", "-p $service{proto} --dport $_ -m mark --mark $nevermark", "wocut-$svcname: blockdirect");} @dports;
	}

for(my $portiter = 1, my $probiter = @dports; $portiter < @dports; $portiter++,$probiter--)
	{
	my $lastmark = $dports[$portiter - 1];
	my $probslice = 1 - (1/$probiter);
	_ipt_do("mangle", "PREROUTING", "-p $service{proto} -m mark --mark $lastmark -m statistic --mode random --probability $probslice --set-mark $dports[$portiter]", "wocut-$svcname: remark for port $dports[$portiter]");
	}
foreach my $dport (@dports)
	{
	_ipt_do("nat", "PREROUTING", "-p $service{proto} -m mark --mark $dport -j REDIRECT --to-port $dport", "wocut-$svcname: redirect");
	}
}

sub ipt_remove
{ # Cleanly remove a wocut ruleset from iptables
my ($svcname) = @_;

my @rules_mangle	= `iptables -v -n --line-numbers -L PREROUTING -t mangle`;
my @rules_nat		= `iptables -v -n --line-numbers -L PREROUTING -t nat`;
map	{
	my ($ruleno) = split(/\s+/);
	system("iptables -t mangle -D $ruleno");
	} grep{/wocut-$svcname:/} @rules_mangle;
map	{
	my ($ruleno) = split(/\s+/);
	system("iptables -t nat -D $ruleno");
	} grep{/wocut-$svcname:/} @rules_nat;
}

sub _ipt_do
{
my ($table, $chain, $contents, $comment) = @_;
docmd("iptables -t $table -A $chain $contents -m comment --comment \"$comment\"");
}

sub do_nevermark
{ # This establishes rules for packet dropping based on marks in the three chains that are the last to see a packet
foreach my $fchain (qw/INPUT OUTPUT FORWARD/)
	{
	_ipt_do("filter", $fchain, "-m mark --mark --nevermark $nevermark -j DROP", "wocut: nevermark");
	}
}

#################
# My normal utilities


sub docmd($)
{
my ($cmdline) = @_;
dprint(2, "IPTABLES: [$cmdline]");
if($doit)
	{
	qx/$cmdline/;
	if($? != 0)
		{die "************Command failed!**********\n";}
	}
}

sub dprint($$)
{
my ($loglvl, $msg) = @_;
if($debuglvl >= $loglvl)
	{print "$msg\n";}
}

